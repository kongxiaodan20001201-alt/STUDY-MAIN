# 📅 Java 架构师学习日志：RocketMQ 与 存储底层原理

**日期**: 2026-02-24
**模块**: E. 消息队列 (RocketMQ) & 计算机体系结构基础
**今日进度**: RocketMQ 核心架构 -> 可靠性机制 -> 存储底层原理 -> 内存/磁盘区别
**状态**: ✅ 深度掌握

---

## 🚀 第一部分：RocketMQ 核心架构 (vs Kafka)

> **核心定位**：专为 **万级 Topic**、**复杂业务逻辑**（订单/支付）设计的金融级消息中间件。

### 1. 架构四大金刚

* **NameServer**:
* **角色**：注册中心（邮局总部）。
* **特性**：**AP 设计** (高可用)，节点间**互不通信** (Share Nothing)。哪怕挂得只剩一台也能工作。
* *对比 ZK*：ZK 是 CP (强一致)，有 Leader 选举，重且复杂。


* **Broker**: 核心苦力，负责存消息、推消息。
* **Producer/Consumer**: 生产者与消费者。

### 2. 存储设计 (最硬核) 💾

RocketMQ 在 Topic 极多时依然保持高性能的秘诀：

* **CommitLog (数据本体)**：
* **机制**：**所有 Topic** 的消息，全部顺序写入**同一个**巨大的文件。
* **目的**：将磁盘 I/O 锁定为 **顺序写 (Sequential Write)**，避免磁头在不同文件间跳跃（随机写）。
* *对比 Kafka*：Kafka 每个 Partition 一个文件，Topic 多了会退化成随机 I/O。


* **ConsumeQueue (索引)**：
* **机制**：异步构建的逻辑队列，只存 Offset 和 Size。
* **目的**：解决读取问题。消费者查索引 -> 拿 Offset -> 读 CommitLog。



---

## 🛡️ 第二部分：高级特性 (可靠性与事务)

### 1. 怎么保证消息不丢？

* **发送端**：同步发送 + 重试机制。
* **服务端 (Broker)**：
* **同步刷盘 (Sync Flush)**：数据落入物理磁盘才返回成功（最安全，性能降 30%）。
* **异步刷盘 (Async Flush)**：数据写到内存 (PageCache) 就返回（最快，断电丢数据）。
* *推荐*：**异步刷盘 + 同步复制** (主从同步)。


* **消费端**：
* **ACK 机制**：业务逻辑返回 `CONSUME_SUCCESS`，Broker 才会更新位点。
* **重试队列**：处理失败不会跳过，而是进入 `%RETRY%` 队列，按阶梯时间（1s, 5s, 10s...）重试 16 次。



### 2. 分布式事务 (最终一致性) ⚔️

解决“数据库扣款”与“发消息”的原子性问题。

* **核心流程**：
1. 发 **半消息 (Half Message)** (消费者不可见)。
2. 执行本地事务 (MySQL)。
3. **Commit/Rollback**：事务成功则提交半消息，消费者可见。


* **回查机制 (Check)**：如果不提交也不回滚（比如发送方挂了），Broker 会主动回查事务状态。

---

## 💻 第三部分：计算机底层原理 (架构师内功)

### 1. 为什么“写内存”比“写磁盘”快？

* **内存 (RAM)**：纳秒级。
* **磁盘 (Disk)**：毫秒级。
* **通用写策略**：所有高性能组件（Redis, Kafka, MySQL, RocketMQ）本质上都是 **“先写内存 (Buffer/PageCache)，再刷盘”**。
* RocketMQ/Kafka 利用 OS 的 **PageCache**。
* MySQL 利用内部的 **Log Buffer**。



### 2. 易失性 vs 非易失性

* **RAM (内存)**：易失性。靠**电容/晶体管**维持状态，断电即失（水桶漏水理论）。
* **Disk (硬盘)**：非易失性。靠**改变物理性质**（磁极翻转/电子陷阱）存数据，断电永存。

### 3. Redis 为什么叫“内存数据库”？

* **定义标准**：
* **服务层 (Serving)**：读写请求全部在内存完成，不产生磁盘 I/O。
* **容量**：受物理内存限制。
* **硬盘作用**：仅作为 **灾难恢复 (Recovery)** 的备份（RDB/AOF），不参与实时读写。

