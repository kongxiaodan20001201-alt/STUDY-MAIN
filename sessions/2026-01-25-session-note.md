# 📅 Java 架构师学习日志：Docker 与 Kubernetes 原理

**日期**: 2026-02-23
**模块**: F. 容器化与云原生 (Containerization & Cloud Native)
**今日进度**: Docker 原理 -> K8s 架构 -> 网络模型 -> 配置管理
**状态**: ✅ 深度掌握底层逻辑

---

## 🐳 1. Docker：所谓的“容器”其实是个谎言

> **核心认知**：容器不是轻量级虚拟机，而是**被“催眠”和“带镣铐”的进程**。

* **隔离 (Namespace)**：
* 让进程“戴上 VR 眼镜”，以为自己 PID=1，以为自己拥有独立的文件系统。
* **本质**：欺骗进程的视图。


* **限制 (Cgroups)**：
* 给进程“戴上项圈”，限制 CPU 和内存使用量。
* **本质**：防止进程无度索取资源。


* **网络 (Bridge)**：
* 默认构建“国中之国”（`172.17.0.0/16`）。
* **跨机冲突**：不同机器上的 Docker 默认会使用相同网段，IP 会重复。
* **解决**：单机映射端口无所谓；跨机互通需靠 K8s 或 Overlay 网络接管。



---

## ☸️ 2. Kubernetes (K8s)：外卖帝国的“超级店长”

> **核心认知**：K8s 不运行容器，它负责**管理**容器的生命周期（生、老、病、死）。

* **核心架构**：
* **Master (大脑)**：Etcd 存数据（唯一状态存储），API Server 也就是前台。
* **Node (手脚)**：Kubelet 也就是工头，指挥 Docker 干活。


* **原子单位 (Pod)**：
* K8s 调度的最小单位不是容器，而是 **Pod (豌豆荚)**。
* **特性**：Pod 内的容器共享 Network Namespace（**共用 IP 和 localhost**）。


* **网络魔法 (CNI + Overlay)**：
* 如何实现跨主机通信？
* **隧道技术 (VXLAN)**：把数据包封装在 UDP 里，“骗”过物理交换机，传送到另一台机器后再拆包。
* **结论**：大部分 K8s 网络是建立在 Bridge 模式之上的增强版，而不是简单的 Host 模式。



---

## ⚙️ 3. 配置管理：ConfigMap vs Nacos

> **核心认知**：配置分层，各司其职。

* **ConfigMap / Secret**：
* **定位**：**基础设施配置**（Bootstrap）。
* **作用**：作为“第一推动力”，把 Nacos 地址、数据库密码注入给 Pod（通常通过环境变量）。


* **Nacos**：
* **定位**：**业务动态配置**。
* **作用**：应用启动后，再去拉取具体的业务开关、规则。



---

## 🧠 架构师视角的纠偏

1. **关于 Host 模式**：
* 虽然快，但会导致端口冲突和安全问题。K8s 生产环境 99% 使用 CNI 插件实现的 **Overlay 网络**，既保留了隔离性，又打通了通信。


2. **关于 IP 冲突**：
* 裸奔的 Docker 在多机部署时 **IP 必然重复**。
* 解决方案是引入 K8s 或 Swarm，让它们用全局账本（Etcd）来分配不重复的 IP。
